[
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "59c88321-3f1a-4f03-92ae-103345d5a883",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC001-test_login_api_authentication",
    "description": "Verify that the login API authenticates users correctly with valid credentials, enforces rate limiting, supports CAPTCHA, and returns appropriate responses for success and failure scenarios.",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/login\"\nHEADERS = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n}\nTIMEOUT = 30\n\ndef test_login_api_authentication():\n    session = requests.Session()\n\n    try:\n        # 1. Test successful login with valid credentials\n        valid_credentials = {\n            \"username\": \"admin\",\n            \"password\": \"correct_password\"\n        }\n        response = session.post(\n            LOGIN_ENDPOINT,\n            data=valid_credentials,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n            allow_redirects=False\n        )\n        # Expecting a 200 status or a redirect (302) to dashboard on success.\n        assert response.status_code in (200, 302), f\"Expected 200 or 302, got {response.status_code}\"\n        # If redirected, location should be dashboard or similar\n        if response.status_code == 302:\n            location = response.headers.get(\"Location\", \"\")\n            assert \"/dashboard\" in location, f\"Expected redirect to dashboard, got {location}\"\n\n        # 2. Test login failure with invalid credentials\n        invalid_credentials = {\n            \"username\": \"admin\",\n            \"password\": \"wrong_password\"\n        }\n        response_fail = session.post(\n            LOGIN_ENDPOINT,\n            data=invalid_credentials,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n            allow_redirects=False\n        )\n        assert response_fail.status_code in (200, 401), f\"Expected 401 or 200 for invalid credentials, got {response_fail.status_code}\"\n        # Check if response content indicates login failure when status is 200\n        if response_fail.status_code == 200:\n            content_lower = response_fail.text.lower()\n            assert \"invalid\" in content_lower or \"login\" in content_lower, \"Login failure not indicated in response content\"\n\n        # 3 & 4. Test rate limiting or CAPTCHA enforcement after multiple failed attempts\n        # Assuming rate limiting or CAPTCHA triggered after several failed attempts\n        limit_triggered = False\n        max_attempts = 10\n        for _ in range(max_attempts):\n            resp = session.post(\n                LOGIN_ENDPOINT,\n                data=invalid_credentials,\n                headers=HEADERS,\n                timeout=TIMEOUT,\n                allow_redirects=False\n            )\n            content_lower = resp.text.lower()\n            if resp.status_code == 429 or \"captcha\" in content_lower:\n                limit_triggered = True\n                break\n        assert limit_triggered, \"Rate limiting or CAPTCHA not enforced or indicated after multiple failed attempts\"\n\n    except (RequestException, Timeout) as e:\n        assert False, f\"Request failed with exception: {e}\"\n\ntest_login_api_authentication()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 68, in test_login_api_authentication\nAssertionError: Rate limiting or CAPTCHA not enforced or indicated after multiple failed attempts\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.246Z",
    "modified": "2025-11-05T17:05:23.930Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "3e621e3e-d895-494c-ae34-3c8be72dce8a",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC002-test_logout_api_session_clearing",
    "description": "Verify that the logout API successfully logs out the user by clearing the session and returns a success response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nLOGIN_URL = f\"{BASE_URL}/login\"\nLOGOUT_URL = f\"{BASE_URL}/logout\"\nTIMEOUT = 30\n\ndef test_logout_api_session_clearing():\n    session = requests.Session()\n    try:\n        # Perform login to obtain a logged-in session (use valid test credentials)\n        login_payload = {\n            \"username\": \"admin\",\n            \"password\": \"admin\"\n        }\n        login_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n        login_response = session.post(LOGIN_URL, data=login_payload, headers=login_headers, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n\n        # Perform logout to clear session\n        logout_response = session.post(LOGOUT_URL, timeout=TIMEOUT)\n        assert logout_response.status_code == 200, f\"Logout failed with status code {logout_response.status_code}\"\n\n        # Optionally, verify session cookies cleared (session cookies no longer present)\n        # Or confirm logout by trying to access a protected page and expect failure (skipped due to scope)\n\n    finally:\n        session.close()\n\ntest_logout_api_session_clearing()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.254Z",
    "modified": "2025-11-05T17:04:32.892Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "def9af94-ba85-4ca1-8fc0-9a3e74e55eb8",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC003-test_dashboard_api_display",
    "description": "Verify that the dashboard API displays the main dashboard page with employee compliance overview and returns a 200 status code.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\ndef test_dashboard_api_display():\n    url = f\"{BASE_URL}/dashboard\"\n    headers = {\n        \"Accept\": \"text/html\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    # Validate status code\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    # Validate that content type is HTML\n    content_type = response.headers.get('Content-Type', '')\n    assert 'text/html' in content_type, f\"Expected 'text/html' in Content-Type header but got {content_type}\"\n\ntest_dashboard_api_display()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.260Z",
    "modified": "2025-11-05T17:04:42.785Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "b5385a86-afde-43d6-9125-4b48454cae49",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC004-test_employee_management_api_crud_operations",
    "description": "Verify CRUD operations for employee records including adding new employees with valid data, retrieving employee details, and handling not found errors.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\ndef test_employee_management_api_crud_operations():\n    session = requests.Session()\n\n    # Step 1: Add a new employee with valid data\n    employee_name = f\"Test Employee {uuid.uuid4()}\"\n    add_emp_url = f\"{BASE_URL}/add_employee\"\n    headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    add_payload = {\"name\": employee_name}\n    try:\n        resp = session.post(add_emp_url, data=add_payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n        \n        # Retrieve employee list to find the ID of the added employee\n        list_emp_url = f\"{BASE_URL}/api/employees\"\n        list_resp = session.get(list_emp_url, timeout=TIMEOUT)\n        list_resp.raise_for_status()\n        assert list_resp.status_code == 200\n        employees = list_resp.json()\n        # Find employee by name\n        employee = next((e for e in employees if e.get(\"name\") == employee_name), None)\n        assert employee is not None, \"Added employee not found in employee list\"\n        employee_id = employee.get(\"id\")\n        assert isinstance(employee_id, int)\n\n        # Step 2: Retrieve employee details - valid employee_id\n        get_emp_url = f\"{BASE_URL}/employee/{employee_id}\"\n        get_resp = session.get(get_emp_url, timeout=TIMEOUT)\n        get_resp.raise_for_status()\n        assert get_resp.status_code == 200\n        # The response should be html or json with employee detail, here we check body presence\n        assert get_resp.text and employee_name in get_resp.text\n\n        # Step 3: Retrieve employee details - invalid employee_id (not found)\n        invalid_employee_id = 99999999  # Assuming this ID does not exist\n        get_invalid_emp_url = f\"{BASE_URL}/employee/{invalid_employee_id}\"\n        invalid_resp = session.get(get_invalid_emp_url, timeout=TIMEOUT)\n        assert invalid_resp.status_code == 404\n\n    finally:\n        # Cleanup: Delete employee data (GDPR right to erasure)\n        # Checking if employee_id was assigned before attempting delete\n        if 'employee_id' in locals():\n            delete_url = f\"{BASE_URL}/admin/dsar/delete/{employee_id}\"\n            try:\n                del_resp = session.post(delete_url, timeout=TIMEOUT)\n                # Accept 200 for successful delete or 404 if already removed\n                assert del_resp.status_code in (200, 404)\n            except Exception:\n                pass\n\ntest_employee_management_api_crud_operations()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 23, in test_employee_management_api_crud_operations\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: NOT FOUND for url: http://localhost:5001/api/employees\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.267Z",
    "modified": "2025-11-05T17:05:03.379Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "652eb866-5d63-4dcb-bb2a-9329d2514a6e",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC005-test_trip_management_api_crud_operations",
    "description": "Verify CRUD operations for employee travel trips including adding, editing, and deleting trips with valid and invalid data, and handling ongoing trip scenarios and overlapping trips.",
    "code": "import requests\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\ndef test_trip_management_api_crud_operations():\n    session = requests.Session()\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n    employee_id = None\n    trip_ids = []\n\n    def create_employee(name=\"Test Employee for Trip\"):\n        resp = session.post(f\"{BASE_URL}/add_employee\", data={\"name\": name}, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        # After adding employee, fetch employees to find the ID\n        emp_list = session.get(f\"{BASE_URL}/api/employees\", timeout=TIMEOUT)\n        emp_list.raise_for_status()\n        employees = emp_list.json()\n        for emp in employees:\n            if emp.get(\"name\") == name:\n                return emp.get(\"id\")\n        raise Exception(\"Failed to create/find employee\")\n\n    def delete_trip(trip_id):\n        resp = session.post(f\"{BASE_URL}/delete_trip/{trip_id}\", headers=headers, timeout=TIMEOUT)\n        if resp.status_code not in (200, 404):\n            resp.raise_for_status()\n\n    def delete_employee(emp_id):\n        # Delete employee by GDPR DSAR delete endpoint\n        resp = session.post(f\"{BASE_URL}/admin/dsar/delete/{emp_id}\", headers=headers, timeout=TIMEOUT)\n        if resp.status_code not in (200, 404):\n            resp.raise_for_status()\n\n    def add_trip(data):\n        resp = session.post(f\"{BASE_URL}/add_trip\", data=data, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    def edit_trip(trip_id, data):\n        resp = session.post(f\"{BASE_URL}/edit_trip/{trip_id}\", data=data, headers=headers, timeout=TIMEOUT)\n        return resp\n\n    try:\n        # Step 1: Create an employee\n        employee_id = create_employee()\n\n        # Dates for trips\n        today = datetime.utcnow().date()\n        past_entry = (today - timedelta(days=20)).isoformat()\n        past_exit = (today - timedelta(days=10)).isoformat()\n        ongoing_entry = (today - timedelta(days=2)).isoformat()\n        ongoing_exit = (today + timedelta(days=5)).isoformat()\n        overlapping_entry = (today - timedelta(days=15)).isoformat()\n        overlapping_exit = (today - timedelta(days=5)).isoformat()\n        future_entry = (today + timedelta(days=6)).isoformat()\n        future_exit = (today + timedelta(days=10)).isoformat()\n        invalid_entry = (today + timedelta(days=10)).isoformat()\n        invalid_exit = (today + timedelta(days=1)).isoformat()  # exit before entry\n\n        # Step 2: Add a valid past trip\n        trip_data_1 = {\n            \"employee_id\": employee_id,\n            \"country\": \"France\",\n            \"entry_date\": past_entry,\n            \"exit_date\": past_exit,\n            \"purpose\": \"Business\"\n        }\n        resp = add_trip(trip_data_1)\n        assert resp.status_code == 200, f\"Failed to add valid past trip: {resp.text}\"\n        resp_json = resp.json() if resp.headers.get('Content-Type', '').startswith('application/json') else {}\n        # ID might not be in response - fetch trips to find it\n        trips_resp = session.get(f\"{BASE_URL}/api/trips\", timeout=TIMEOUT)\n        trips_resp.raise_for_status()\n        trips = trips_resp.json().get(\"trips\", [])\n        trip_1 = next((t for t in trips if t[\"employee_id\"] == employee_id and t[\"entry_date\"] == past_entry and t[\"exit_date\"] == past_exit), None)\n        assert trip_1 is not None, \"Added trip not found in trip list\"\n        trip_1_id = trip_1[\"id\"]\n        trip_ids.append(trip_1_id)\n\n        # Step 3: Add an ongoing trip (entry date in past, exit date in future)\n        trip_data_ongoing = {\n            \"employee_id\": employee_id,\n            \"country\": \"Germany\",\n            \"entry_date\": ongoing_entry,\n            \"exit_date\": ongoing_exit,\n            \"purpose\": \"Conference\"\n        }\n        resp = add_trip(trip_data_ongoing)\n        assert resp.status_code == 200, f\"Failed to add ongoing trip: {resp.text}\"\n        trips_resp = session.get(f\"{BASE_URL}/api/trips\", timeout=TIMEOUT)\n        trips_resp.raise_for_status()\n        trips = trips_resp.json().get(\"trips\", [])\n        trip_ongoing = next((t for t in trips if t[\"employee_id\"] == employee_id and t[\"entry_date\"] == ongoing_entry and t[\"exit_date\"] == ongoing_exit), None)\n        assert trip_ongoing is not None, \"Added ongoing trip not found\"\n        trip_ongoing_id = trip_ongoing[\"id\"]\n        trip_ids.append(trip_ongoing_id)\n\n        # Step 4: Attempt to add overlapping trip for same employee - expect failure or validation\n        overlapping_trip_data = {\n            \"employee_id\": employee_id,\n            \"country\": \"Italy\",\n            \"entry_date\": overlapping_entry,\n            \"exit_date\": overlapping_exit,\n            \"purpose\": \"Vacation\"\n        }\n        resp = add_trip(overlapping_trip_data)\n        # This can be either a validation error or success depending on business rule enforced by backend\n        # We'll assert that either 400 or 200 response is received and if 200, the trip must not overlap logically\n        if resp.status_code == 200:\n            trips_resp = session.get(f\"{BASE_URL}/api/trips\", timeout=TIMEOUT)\n            trips_resp.raise_for_status()\n            trips = trips_resp.json().get(\"trips\", [])\n            trip_overlap = next((t for t in trips if t[\"employee_id\"] == employee_id and t[\"entry_date\"] == overlapping_entry and t[\"exit_date\"] == overlapping_exit), None)\n            assert trip_overlap is None, \"Overlapping trip was incorrectly added\"\n        else:\n            assert resp.status_code == 400 or resp.status_code == 409, f\"Unexpected status for overlapping trip: {resp.status_code}, {resp.text}\"\n\n        # Step 5: Add a future trip after ongoing (non-overlapping allowed)\n        future_trip_data = {\n            \"employee_id\": employee_id,\n            \"country\": \"Spain\",\n            \"entry_date\": future_entry,\n            \"exit_date\": future_exit,\n            \"purpose\": \"Training\"\n        }\n        resp = add_trip(future_trip_data)\n        assert resp.status_code == 200, f\"Failed to add valid future trip: {resp.text}\"\n        trips_resp = session.get(f\"{BASE_URL}/api/trips\", timeout=TIMEOUT)\n        trips_resp.raise_for_status()\n        trips = trips_resp.json().get(\"trips\", [])\n        trip_future = next((t for t in trips if t[\"employee_id\"] == employee_id and t[\"entry_date\"] == future_entry and t[\"exit_date\"] == future_exit), None)\n        assert trip_future is not None, \"Added future trip not found\"\n        trip_future_id = trip_future[\"id\"]\n        trip_ids.append(trip_future_id)\n\n        # Step 6: Try to add trip with invalid date range (exit before entry) - expect 400\n        invalid_trip_data = {\n            \"employee_id\": employee_id,\n            \"country\": \"Netherlands\",\n            \"entry_date\": invalid_entry,\n            \"exit_date\": invalid_exit,\n            \"purpose\": \"Invalid\"\n        }\n        resp = add_trip(invalid_trip_data)\n        assert resp.status_code == 400, f\"Invalid trip date range should fail with 400 but got {resp.status_code}\"\n\n        # Step 7: Edit an existing trip with a valid update (change country)\n        new_country = \"Belgium\"\n        edit_data = {\n            \"country\": new_country,\n            \"entry_date\": past_entry,\n            \"exit_date\": past_exit\n        }\n        resp = edit_trip(trip_1_id, edit_data)\n        assert resp.status_code == 200, f\"Failed to edit trip: {resp.text}\"\n\n        # Verify edit\n        resp = session.get(f\"{BASE_URL}/api/trips/{trip_1_id}\", timeout=TIMEOUT)\n        if resp.status_code == 404:\n            raise AssertionError(\"Edited trip not found after update\")\n        resp.raise_for_status()\n        trip_details = resp.json()\n        assert trip_details.get(\"country\") == new_country, \"Trip country not updated correctly\"\n\n        # Step 8: Edit trip with invalid data (exit date before entry) - expect error\n        invalid_edit_data = {\n            \"country\": \"USA\",\n            \"entry_date\": invalid_entry,\n            \"exit_date\": invalid_exit\n        }\n        resp = edit_trip(trip_1_id, invalid_edit_data)\n        assert resp.status_code == 400 or resp.status_code == 422, f\"Invalid edit did not return expected error, got {resp.status_code}\"\n\n        # Step 9: Delete a trip\n        resp = session.delete(f\"{BASE_URL}/api/trips/{trip_future_id}\", timeout=TIMEOUT)\n        if resp.status_code == 404:\n            # fallback to legacy post delete endpoint\n            resp_del_post = session.post(f\"{BASE_URL}/delete_trip/{trip_future_id}\", headers=headers, timeout=TIMEOUT)\n            assert resp_del_post.status_code == 200 or resp_del_post.status_code == 404, \"Failed to delete trip with fallback endpoint\"\n        else:\n            assert resp.status_code == 200, \"Failed to delete future trip\"\n\n        # Verify deletion\n        resp_check = session.get(f\"{BASE_URL}/api/trips/{trip_future_id}\", timeout=TIMEOUT)\n        assert resp_check.status_code == 404, \"Deleted trip still retrievable\"\n\n    finally:\n        # Cleanup: delete created trips and employee\n        for tid in trip_ids:\n            try:\n                session.delete(f\"{BASE_URL}/api/trips/{tid}\", timeout=TIMEOUT)\n            except Exception:\n                try:\n                    session.post(f\"{BASE_URL}/delete_trip/{tid}\", headers=headers, timeout=TIMEOUT)\n                except Exception:\n                    pass\n        if employee_id:\n            try:\n                delete_employee(employee_id)\n            except Exception:\n                pass\n\ntest_trip_management_api_crud_operations()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 204, in <module>\n  File \"<string>\", line 46, in test_trip_management_api_crud_operations\n  File \"<string>\", line 18, in create_employee\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: NOT FOUND for url: http://localhost:5001/api/employees\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.273Z",
    "modified": "2025-11-05T17:04:40.427Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "93b58c8e-aa17-46ad-9eb7-de07c0dc214f",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC006-test_calendar_api_trip_operations_and_filters",
    "description": "Verify calendar API endpoints for listing employees, retrieving trips with optional date filters, creating, updating, deleting, and duplicating trips, and fetching compliance forecasts and alerts.",
    "code": "import requests\nfrom datetime import date, timedelta\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\n\ndef test_calendar_api_trip_operations_and_filters():\n    session = requests.Session()\n\n    # Step 1: List all employees via /api/employees\n    employees_resp = session.get(f\"{BASE_URL}/api/employees\", timeout=TIMEOUT)\n    assert employees_resp.status_code == 200\n    employees_data = employees_resp.json()\n    assert isinstance(employees_data, list)\n    # Ensure employees have id, name, active\n    assert all(\"id\" in e and \"name\" in e and \"active\" in e for e in employees_data)\n    assert len(employees_data) > 0, \"No employees found to test with\"\n    employee_id = employees_data[0][\"id\"]\n\n    # Step 2: Retrieve trips with optional date filters via /api/trips?start=...&end=...\n    # Use a date range that covers at least some time\n    start_filter = (date.today() - timedelta(days=180)).isoformat()\n    end_filter = date.today().isoformat()\n    trips_resp = session.get(f\"{BASE_URL}/api/trips\", params={\"start\": start_filter, \"end\": end_filter}, timeout=TIMEOUT)\n    assert trips_resp.status_code == 200\n    trips_data = trips_resp.json()\n    # Expect keys: employees (array), trips (array), alerts (array)\n    assert isinstance(trips_data, dict)\n    assert \"employees\" in trips_data and \"trips\" in trips_data and \"alerts\" in trips_data\n    assert isinstance(trips_data[\"employees\"], list)\n    assert isinstance(trips_data[\"trips\"], list)\n    assert isinstance(trips_data[\"alerts\"], list)\n\n    # --- Create a new trip because we need a trip ID for update, delete and duplicate tests ---\n    new_trip_payload = {\n        \"employee_id\": employee_id,\n        \"country\": \"FR\",\n        \"start_date\": (date.today() + timedelta(days=1)).isoformat(),\n        \"end_date\": (date.today() + timedelta(days=5)).isoformat(),\n    }\n    create_resp = session.post(f\"{BASE_URL}/api/trips\", json=new_trip_payload, timeout=TIMEOUT)\n    assert create_resp.status_code == 201\n    created_trip = create_resp.json()\n    # Trip creation might return full trip object or at least contain 'id'\n    # If no body or id, fallback to retrieving trips to find latest, but here we assume id in json\n    trip_id = created_trip.get(\"id\")\n    assert trip_id is not None, \"Created trip ID not returned.\"\n\n    try:\n        # Step 3: Update trip via PATCH /api/trips/{trip_id}\n        update_payload = {\n            \"country\": \"DE\",\n            \"start_date\": new_trip_payload[\"start_date\"],\n            \"end_date\": (date.today() + timedelta(days=6)).isoformat(),\n        }\n        update_resp = session.patch(f\"{BASE_URL}/api/trips/{trip_id}\", json=update_payload, timeout=TIMEOUT)\n        assert update_resp.status_code == 200\n\n        # Step 4: Get trip by ID GET /api/trips/{trip_id}\n        get_trip_resp = session.get(f\"{BASE_URL}/api/trips/{trip_id}\", timeout=TIMEOUT)\n        assert get_trip_resp.status_code == 200\n        trip_detail = get_trip_resp.json()\n        assert trip_detail[\"id\"] == trip_id\n        assert trip_detail[\"country\"] == update_payload[\"country\"]\n        assert trip_detail[\"start_date\"] == update_payload[\"start_date\"]\n        assert trip_detail[\"end_date\"] == update_payload[\"end_date\"]\n\n        # Step 5: Duplicate trip POST /api/trips/{trip_id}/duplicate\n        duplicate_resp = session.post(f\"{BASE_URL}/api/trips/{trip_id}/duplicate\", timeout=TIMEOUT)\n        assert duplicate_resp.status_code == 201\n        duplicated_trip = duplicate_resp.json()\n        duplicated_trip_id = duplicated_trip.get(\"id\")\n        assert duplicated_trip_id is not None\n        assert duplicated_trip_id != trip_id\n\n        # Cleanup duplicated trip\n        del_dup_resp = session.delete(f\"{BASE_URL}/api/trips/{duplicated_trip_id}\", timeout=TIMEOUT)\n        assert del_dup_resp.status_code == 200\n\n        # Step 6: Fetch compliance forecast for employee GET /api/forecast/{employee_id}\n        forecast_resp = session.get(f\"{BASE_URL}/api/forecast/{employee_id}\", timeout=TIMEOUT)\n        assert forecast_resp.status_code == 200\n        forecast_data = forecast_resp.json()\n        # Validate forecast keys and types\n        assert \"used_days\" in forecast_data and isinstance(forecast_data[\"used_days\"], int)\n        assert \"upcoming_days\" in forecast_data and isinstance(forecast_data[\"upcoming_days\"], int)\n        assert \"projected_total\" in forecast_data and isinstance(forecast_data[\"projected_total\"], int)\n        assert \"risk_level\" in forecast_data and isinstance(forecast_data[\"risk_level\"], str)\n\n        # Step 7: Fetch active compliance alerts via /api/alerts\n        alerts_resp = session.get(f\"{BASE_URL}/api/alerts\", timeout=TIMEOUT)\n        assert alerts_resp.status_code == 200\n        alerts_data = alerts_resp.json()\n        assert \"alerts\" in alerts_data and isinstance(alerts_data[\"alerts\"], list)\n\n        # Optionally test alerts filter by risk (if any alerts exist)\n        if alerts_data[\"alerts\"]:\n            risk_level = alerts_data[\"alerts\"][0].get(\"risk_level\")\n            if risk_level:\n                alerts_filtered_resp = session.get(f\"{BASE_URL}/api/alerts\", params={\"risk\": risk_level}, timeout=TIMEOUT)\n                assert alerts_filtered_resp.status_code == 200\n                filtered_alerts = alerts_filtered_resp.json()\n                assert \"alerts\" in filtered_alerts\n\n    finally:\n        # Step 8: Delete created trip DELETE /api/trips/{trip_id}\n        del_resp = session.delete(f\"{BASE_URL}/api/trips/{trip_id}\", timeout=TIMEOUT)\n        # Allow 200 or 404 if already deleted by duplicate test cleanup\n        assert del_resp.status_code in [200, 404]\n\n\ntest_calendar_api_trip_operations_and_filters()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 113, in <module>\n  File \"<string>\", line 13, in test_calendar_api_trip_operations_and_filters\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.279Z",
    "modified": "2025-11-05T17:04:42.804Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "c0a9d6c3-f0d2-44ae-82ed-55e6178f374d",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC007-test_health_check_api_endpoints",
    "description": "Verify health check API endpoints for service status including health, readiness, liveness probes, and version information, ensuring correct status codes and response content.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\ndef test_health_check_api_endpoints():\n    endpoints = {\n        \"health\": \"/health\",\n        \"readiness\": \"/health/ready\",\n        \"liveness\": \"/health/live\",\n        \"simple_health\": \"/healthz\",\n        \"version\": \"/api/version\"\n    }\n    try:\n        # Test /health endpoint\n        resp = requests.get(f\"{BASE_URL}{endpoints['health']}\", timeout=TIMEOUT)\n        assert resp.status_code in (200, 503)\n        if resp.status_code == 200:\n            json_data = resp.json()\n            assert \"status\" in json_data and isinstance(json_data[\"status\"], str)\n            assert \"timestamp\" in json_data and isinstance(json_data[\"timestamp\"], str)\n            assert \"service\" in json_data and isinstance(json_data[\"service\"], str)\n\n        # Test /health/ready endpoint\n        resp = requests.get(f\"{BASE_URL}{endpoints['readiness']}\", timeout=TIMEOUT)\n        assert resp.status_code in (200, 503)\n\n        # Test /health/live endpoint\n        resp = requests.get(f\"{BASE_URL}{endpoints['liveness']}\", timeout=TIMEOUT)\n        assert resp.status_code == 200\n\n        # Test /healthz endpoint\n        resp = requests.get(f\"{BASE_URL}{endpoints['simple_health']}\", timeout=TIMEOUT)\n        assert resp.status_code == 200\n        assert resp.text.strip() == \"OK\"\n\n        # Test /api/version endpoint\n        resp = requests.get(f\"{BASE_URL}{endpoints['version']}\", timeout=TIMEOUT)\n        assert resp.status_code == 200\n        json_data = resp.json()\n        assert \"version\" in json_data and isinstance(json_data[\"version\"], str)\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_health_check_api_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 17, in test_health_check_api_endpoints\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.284Z",
    "modified": "2025-11-05T17:05:01.574Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "598b004c-6302-43b1-a8eb-b67af2d47b45",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC008-test_export_api_data_downloads",
    "description": "Verify export API endpoints for downloading trip data as CSV, employee reports as PDF, and all employees reports as PDF, ensuring correct file formats and content.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\nHEADERS_JSON = {\"Accept\": \"application/json\"}\n\n\ndef test_export_api_data_downloads():\n    # Step 1: Create a new employee to use for employee report export\n    employee_data = {\"name\": \"Test User For Export\"}\n    add_employee_url = f\"{BASE_URL}/add_employee\"\n    employee_id = None\n\n    try:\n        resp_add = requests.post(add_employee_url, data=employee_data, timeout=TIMEOUT)\n        assert resp_add.status_code == 200, f\"Failed to add employee, status code: {resp_add.status_code}\"\n        # Although not explicitly documented, the employee id is expected to be set in Location header or response content\n        # We try to retrieve the employee list from /api/employees and find the employee by name to get the id:\n        employees_resp = requests.get(f\"{BASE_URL}/api/employees\", timeout=TIMEOUT)\n        assert employees_resp.status_code == 200, \"Failed to get employees list\"\n        employees = employees_resp.json()\n        matching_emps = [e for e in employees if e.get(\"name\") == employee_data[\"name\"]]\n        assert matching_emps, \"Added employee not found in employee list\"\n        employee_id = matching_emps[0].get(\"id\")\n        assert isinstance(employee_id, int), \"Invalid employee_id obtained\"\n\n        # Step 2: Download trip data CSV\n        trip_csv_url = f\"{BASE_URL}/export/trips/csv\"\n        resp_csv = requests.get(trip_csv_url, timeout=TIMEOUT)\n        assert resp_csv.status_code == 200, f\"Trip CSV export failed with status {resp_csv.status_code}\"\n        content_type_csv = resp_csv.headers.get(\"Content-Type\", \"\")\n        assert \"text/csv\" in content_type_csv, f\"Incorrect Content-Type for trip CSV export: {content_type_csv}\"\n        content_csv = resp_csv.content\n        assert content_csv.startswith(b\"Employee\") or b\",\" in content_csv, \"CSV content does not appear valid\"\n\n        # Step 3: Download employee report PDF for created employee\n        employee_pdf_url = f\"{BASE_URL}/export/employee/{employee_id}/pdf\"\n        resp_pdf_single = requests.get(employee_pdf_url, timeout=TIMEOUT)\n        assert resp_pdf_single.status_code == 200, f\"Employee PDF export failed with status {resp_pdf_single.status_code}\"\n        content_type_pdf_single = resp_pdf_single.headers.get(\"Content-Type\", \"\")\n        assert \"application/pdf\" in content_type_pdf_single, f\"Incorrect Content-Type for employee PDF export: {content_type_pdf_single}\"\n        content_pdf_single = resp_pdf_single.content\n        assert content_pdf_single.startswith(b\"%PDF\") or b\"PDF\" in content_pdf_single[:10], \"PDF content does not appear valid\"\n\n        # Step 4: Download all employees report PDF\n        all_employees_pdf_url = f\"{BASE_URL}/export/all/pdf\"\n        resp_pdf_all = requests.get(all_employees_pdf_url, timeout=TIMEOUT)\n        assert resp_pdf_all.status_code == 200, f\"All employees PDF export failed with status {resp_pdf_all.status_code}\"\n        content_type_pdf_all = resp_pdf_all.headers.get(\"Content-Type\", \"\")\n        assert \"application/pdf\" in content_type_pdf_all, f\"Incorrect Content-Type for all employees PDF export: {content_type_pdf_all}\"\n        content_pdf_all = resp_pdf_all.content\n        assert content_pdf_all.startswith(b\"%PDF\") or b\"PDF\" in content_pdf_all[:10], \"PDF content does not appear valid\"\n\n    finally:\n        # Cleanup: delete the created employee if possible\n        if employee_id is not None:\n            # No explicit delete endpoint documented, so skipping actual deletion\n            # If there was a delete, it would be used here\n            pass\n\n\ntest_export_api_data_downloads()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 20, in test_export_api_data_downloads\nAssertionError: Failed to get employees list\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.291Z",
    "modified": "2025-11-05T17:04:45.568Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "100dea54-5def-45d5-b185-fdd61508283e",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC009-test_admin_dsar_api_gdpr_data_management",
    "description": "Verify GDPR Data Subject Access Request endpoints for exporting employee data as ZIP, deleting employee data, rectifying employee names, and anonymizing employee data, ensuring compliance with privacy laws.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\ndef test_admin_dsar_api_gdpr_data_management():\n    session = requests.Session()\n    employee_id = None\n    try:\n        # Step 1: Create a new employee (needed for DSAR operations)\n        add_employee_url = f\"{BASE_URL}/add_employee\"\n        new_employee_name = \"GDPR Test Employee\"\n        add_resp = session.post(\n            add_employee_url,\n            data={\"name\": new_employee_name},\n            timeout=TIMEOUT\n        )\n        assert add_resp.status_code == 200, \"Failed to add new employee\"\n        # The response presumably contains redirect or success message but no ID; obtain by searching employees\n        # Since no direct get all employees in add_employee, try API employees list\n        employees_resp = session.get(f\"{BASE_URL}/api/employees\", timeout=TIMEOUT)\n        assert employees_resp.status_code == 200, \"Failed to list employees\"\n        employees = employees_resp.json()\n        # Find employee by name\n        matched = [e for e in employees if e.get(\"name\") == new_employee_name]\n        assert matched, \"Newly added employee not found in employees list\"\n        employee_id = matched[0][\"id\"]\n\n        # Step 2: Export employee data as DSAR ZIP\n        export_url = f\"{BASE_URL}/admin/dsar/export/{employee_id}\"\n        export_resp = session.get(export_url, timeout=TIMEOUT)\n        assert export_resp.status_code == 200, \"Failed to export DSAR ZIP\"\n        content_type = export_resp.headers.get(\"Content-Type\", \"\")\n        assert \"application/zip\" in content_type, f\"Unexpected content type for DSAR export: {content_type}\"\n        content_length = export_resp.headers.get(\"Content-Length\")\n        assert content_length is None or int(content_length) > 0, \"Empty content in DSAR export\"\n\n        # Step 3: Rectify employee name\n        rectify_url = f\"{BASE_URL}/admin/dsar/rectify/{employee_id}\"\n        new_name = \"GDPR Test Employee Rectified\"\n        rectify_resp = session.post(\n            rectify_url,\n            data={\"name\": new_name},\n            timeout=TIMEOUT\n        )\n        assert rectify_resp.status_code == 200, \"Failed to rectify employee name\"\n        # Verify rectification by re-fetching employee details\n        get_employee_url = f\"{BASE_URL}/employee/{employee_id}\"\n        get_emp_resp = session.get(get_employee_url, timeout=TIMEOUT)\n        assert get_emp_resp.status_code == 200, \"Failed to fetch employee details after rectification\"\n        assert new_name in get_emp_resp.text, \"Employee name not updated after rectification\"\n\n        # Step 4: Anonymize employee data\n        anonymize_url = f\"{BASE_URL}/admin/dsar/anonymize/{employee_id}\"\n        anonymize_resp = session.post(anonymize_url, timeout=TIMEOUT)\n        assert anonymize_resp.status_code == 200, \"Failed to anonymize employee data\"\n        # Verify anonymization by fetching employee details and checking name is anonymized (not equal to previous)\n        get_emp_post_anon_resp = session.get(get_employee_url, timeout=TIMEOUT)\n        assert get_emp_post_anon_resp.status_code == 200, \"Failed to fetch employee after anonymization\"\n        # Name should not be the rectified name; minimally check rectified name absent\n        assert new_name not in get_emp_post_anon_resp.text, \"Employee name not anonymized\"\n\n        # Step 5: Delete employee data\n        delete_url = f\"{BASE_URL}/admin/dsar/delete/{employee_id}\"\n        delete_resp = session.post(delete_url, timeout=TIMEOUT)\n        assert delete_resp.status_code == 200, \"Failed to delete employee data\"\n\n        # Step 6: Confirm deletion: employee detail should return 404 or equivalent\n        get_emp_after_delete_resp = session.get(get_employee_url, timeout=TIMEOUT)\n        assert get_emp_after_delete_resp.status_code == 404 or get_emp_after_delete_resp.status_code == 200 and \"not found\" in get_emp_after_delete_resp.text.lower(), \"Employee data still exists after deletion\"\n    finally:\n        # Cleanup in case employee data was not deleted\n        if employee_id is not None:\n            # Try delete again to clean up\n            try:\n                session.post(f\"{BASE_URL}/admin/dsar/delete/{employee_id}\", timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_admin_dsar_api_gdpr_data_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 22, in test_admin_dsar_api_gdpr_data_management\nAssertionError: Failed to list employees\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.296Z",
    "modified": "2025-11-05T17:04:47.100Z"
  },
  {
    "projectId": "18afb123-5415-47f7-a808-d4275772bf7d",
    "testId": "5bc5cf30-e7b6-4180-8cc2-61970938d9a6",
    "userId": "0478a4d8-9001-7004-94e6-8f398bab7876",
    "title": "TC010-test_admin_retention_api_data_purging",
    "description": "Verify data retention management endpoints for previewing expired trips, listing expired trips, and purging expired trips, ensuring correct identification and removal of data according to retention policies.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5001\"\nTIMEOUT = 30\n\nHEADERS = {\n    'Accept': 'application/json'\n}\n\n\ndef test_admin_retention_api_data_purging():\n    # Preview expired trips\n    preview_url = f\"{BASE_URL}/api/retention/preview\"\n    try:\n        preview_response = requests.get(preview_url, headers=HEADERS, timeout=TIMEOUT)\n        preview_response.raise_for_status()\n        preview_data = preview_response.json()\n        assert isinstance(preview_data, dict), \"Preview response is not a JSON object\"\n        assert \"expired_trips\" in preview_data, \"'expired_trips' key missing in preview response\"\n        expired_trips = preview_data[\"expired_trips\"]\n        assert isinstance(expired_trips, list), \"'expired_trips' is not a list\"\n    except requests.RequestException as e:\n        assert False, f\"Preview expired trips request failed: {str(e)}\"\n\n    # List expired trips page\n    list_url = f\"{BASE_URL}/admin/retention/expired\"\n    try:\n        list_response = requests.get(list_url, headers=HEADERS, timeout=TIMEOUT)\n        assert list_response.status_code == 200, f\"Expired trips listing failed with status {list_response.status_code}\"\n        # Content can be HTML page, so no JSON assertion here. Just check content existence.\n        assert list_response.content, \"Expired trips list response has no content\"\n    except requests.RequestException as e:\n        assert False, f\"List expired trips request failed: {str(e)}\"\n\n    # Purge expired trips\n    purge_url = f\"{BASE_URL}/admin/retention/purge\"\n    try:\n        purge_response = requests.post(purge_url, headers=HEADERS, timeout=TIMEOUT)\n        purge_response.raise_for_status()\n        # Purge API returns a 200 status and confirmation text presumably\n        assert \"purged\" in purge_response.text.lower(), \"Purge confirmation not found in response\"\n    except requests.RequestException as e:\n        assert False, f\"Purge expired trips request failed: {str(e)}\"\n\n\ntest_admin_retention_api_data_purging()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 16, in test_admin_retention_api_data_purging\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: UNAUTHORIZED for url: http://localhost:5001/api/retention/preview\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 23, in test_admin_retention_api_data_purging\nAssertionError: Preview expired trips request failed: 401 Client Error: UNAUTHORIZED for url: http://localhost:5001/api/retention/preview\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-05T17:03:46.302Z",
    "modified": "2025-11-05T17:05:13.915Z"
  }
]
